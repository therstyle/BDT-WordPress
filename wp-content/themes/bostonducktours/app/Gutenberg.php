<?php

namespace BostonDuckTours;

class Gutenberg {

	/**
	 * Which post types support the Gutenberg editor?
	 *
	 * Other post types will not have the required scripts enqueued.
	 *
	 * @var array
	 */
	static $allowed_post_types = [
		'post',
		'page',
		'discount',
		'nested_block'
	];

	/**
	 * Initialize custom Gutenberg functionalities - custom blocks,
	 * styles, etc.
	 */
	public static function init(): void {
		self::init_full_width_editor();
		self::init_custom_blocks();
		self::init_block_styles();
	}

	/**
	 * Make the Gutenberg editor full width.
	 */
	public static function init_full_width_editor(): void {
		add_action( 'admin_head', function () {
			echo '<style>
			    body.gutenberg-editor-page .editor-post-title__block,
			    body.gutenberg-editor-page .editor-default-block-appender,
			    body.gutenberg-editor-page .editor-block-list__block {
					max-width: none !important;
				}

			    .block-editor__container .wp-block {
			        max-width: none !important;
			    }
			</style>';
		} );
	}

	/**
	 * Add custom Gutenberg blocks.
	 *
	 * These are implemented using ACF.
	 */
	public static function init_custom_blocks(): void {
		add_action( 'acf/init', function () {
			if ( ! function_exists( 'acf_register_block' ) ) {
				return;
			}

			include_once get_template_directory() . '/blocks/register.php';
		} );
	}

	/**
	 * Add styles for custom Gutenberg blocks.
	 */
	public static function init_block_styles(): void {
		add_action( 'admin_enqueue_scripts', function ( $hook ) {
			if (
				$hook !== 'post.php'
				|| ! in_array( get_post_type(), self::$allowed_post_types )
			) {
				return;
			}

			$bundles = glob( get_template_directory() . '/blocks/js/modern/bundle*' );
			if ( ! $bundles ) {
				// TODO: Should we display some kind of error?

				return;
			}

			wp_enqueue_script(
				'custom-blocks',
				get_template_directory_uri() . '/blocks/js/modern/' . basename( $bundles[0] ),
				[ 'wp-i18n' ],
				false,
				true
			);

			wp_set_script_translations( 'custom-blocks', 'bostonducktours' );
		} );
	}

	/**
	 * The data returned from default WP "parse_blocks" in case of
	 * ACF fields is almost useful, but not quite. We get the values
	 * of all ACF fields, but they are indexed by the key (field_XYZ),
	 * not the name of the field, so we can't really use those
	 * on frontend, because we don't know what the fields are.
	 *
	 * This function converts whatever ACF spits out to an associative
	 * array field name (as set in settings) => field value.
	 *
	 * @param string $block_id
	 * @param array $fields
	 *
	 * @return array
	 */
	public static function parse_block_acf_fields( string $block_id, $fields ): array {
		// Replace ACF fields generated by default (indexed by key)
		// with the same data as we'd normally get on the frontend,
		// fields indexed by name with correct values.
		acf_setup_meta( $fields, $block_id, true );
		$parsed_fields = get_fields();
		acf_reset_meta( $block_id );

		return self::convert_acf_fields( $parsed_fields );
	}

	/**
	 * Get all fields from a block, and convert their values to something
	 * usable by the frontend.
	 *
	 * While most of the fields returned by ACF are ok (strings, for example),
	 * sometimes we might need to return full source of an SVG image, not just
	 * the URL, or retrieve blocks for post object, etc.
	 *
	 * @param array $fields
	 *
	 * @return array
	 */
	public static function convert_acf_fields( $fields ): array {
		if ( ! $fields ) {
			return [];
		}

		$converted_fields = [];
		foreach ( $fields as $name => $value ) {
			$new_value = self::convert_acf_field( $value );

			// If we've got a value different than null, that means
			// the conversion was done, and we store the new value
			// in the field.
			if ( $new_value !== null ) {
				$converted_fields[ $name ] = $new_value;

				continue;
			}

			// null means that no conversion was done, and we probably
			// should keep the value of the field as returned from the DB.

			// Recursively convert values in arrays.
			if ( is_array( $value ) ) {
				$converted_fields[ $name ] = self::convert_acf_fields( $value );

				continue;
			}

			// Conversion was not performed, the value is plain (not an array).
			// Just store it.
			$converted_fields[ $name ] = $value;
		}

		return $converted_fields;
	}

	/**
	 * Convert a single ACF field.
	 *
	 * @see self::convert_acf_fields
	 *
	 * @param mixed $field_value
	 *
	 * @return mixed
	 */
	public static function convert_acf_field( $field_value ) {
		// Post.
		// Pass it through our parser (Post class) to always return
		// the same structure to the frontend.
		if ( $field_value instanceof \WP_Post ) {
			$post = new Post( $field_value );

			return $post->get_formatted_data();
		}

		// Image.
		// Pass it through Image class to give frontend access to all
		// image sizes, and srcsets generated by WP.
		if (
			is_array( $field_value )
			&& isset( $field_value['ID'] )
			&& get_post_type( (int) $field_value['ID'] ) === 'attachment'
		) {
			$media_resolver = new Media( (int) $field_value['ID'] );
			$attachment     = $media_resolver->resolve_media_class();

			return $attachment->get_formatted_data();
		}

		return null;
	}

	/**
	 * Render a single Gutenberg block.
	 *
	 * We want to be able to use the same React components on frontend and in backend
	 * to avoid creating the blocks twice. To do that we just print a div to insert
	 * React component in, and an inline script that calls a global function
	 * (exposed by the bundle generated for Gutenberg) that will render the block.
	 *
	 * @param array $block
	 */
	public static function render_block( array $block ): void {
		$block_id = $block['id'];
		$props    = self::parse_block_acf_fields( $block['id'], $block['data'] );

		?>

        <div id="<?php echo $block_id; ?>"></div>
        <script type="text/javascript">
            const <?php echo $block_id; ?> =
            document.getElementById('<?php echo $block_id; ?>');
            themeCustomBlocks.block(
				<?php echo $block_id; ?>,
                '<?php echo $block['name']; ?>',
				<?php echo json_encode( $props ); ?>
            );
        </script>

		<?php
	}
}
